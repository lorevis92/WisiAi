{"ast":null,"code":"/**\n * @license Angular v14.0.0\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\nimport { ComponentFactoryResolver, NgZone, Injector, ChangeDetectorRef, ApplicationRef, SimpleChange, Version } from '@angular/core';\nimport { ReplaySubject, merge } from 'rxjs';\nimport { switchMap, map } from 'rxjs/operators';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Provide methods for scheduling the execution of a callback.\n */\n\nconst scheduler = {\n  /**\n   * Schedule a callback to be called after some delay.\n   *\n   * Returns a function that when executed will cancel the scheduled function.\n   */\n  schedule(taskFn, delay) {\n    const id = setTimeout(taskFn, delay);\n    return () => clearTimeout(id);\n  },\n\n  /**\n   * Schedule a callback to be called before the next render.\n   * (If `window.requestAnimationFrame()` is not available, use `scheduler.schedule()` instead.)\n   *\n   * Returns a function that when executed will cancel the scheduled function.\n   */\n  scheduleBeforeRender(taskFn) {\n    // TODO(gkalpak): Implement a better way of accessing `requestAnimationFrame()`\n    //                (e.g. accounting for vendor prefix, SSR-compatibility, etc).\n    if (typeof window === 'undefined') {\n      // For SSR just schedule immediately.\n      return scheduler.schedule(taskFn, 0);\n    }\n\n    if (typeof window.requestAnimationFrame === 'undefined') {\n      const frameMs = 16;\n      return scheduler.schedule(taskFn, frameMs);\n    }\n\n    const id = window.requestAnimationFrame(taskFn);\n    return () => window.cancelAnimationFrame(id);\n  }\n\n};\n/**\n * Convert a camelCased string to kebab-cased.\n */\n\nfunction camelToDashCase(input) {\n  return input.replace(/[A-Z]/g, char => `-${char.toLowerCase()}`);\n}\n/**\n * Check whether the input is an `Element`.\n */\n\n\nfunction isElement(node) {\n  return !!node && node.nodeType === Node.ELEMENT_NODE;\n}\n/**\n * Check whether the input is a function.\n */\n\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n/**\n * Convert a kebab-cased string to camelCased.\n */\n\n\nfunction kebabToCamelCase(input) {\n  return input.replace(/-([a-z\\d])/g, (_, char) => char.toUpperCase());\n}\n\nlet _matches;\n/**\n * Check whether an `Element` matches a CSS selector.\n * NOTE: this is duplicated from @angular/upgrade, and can\n * be consolidated in the future\n */\n\n\nfunction matchesSelector(el, selector) {\n  if (!_matches) {\n    const elProto = Element.prototype;\n    _matches = elProto.matches || elProto.matchesSelector || elProto.mozMatchesSelector || elProto.msMatchesSelector || elProto.oMatchesSelector || elProto.webkitMatchesSelector;\n  }\n\n  return el.nodeType === Node.ELEMENT_NODE ? _matches.call(el, selector) : false;\n}\n/**\n * Test two values for strict equality, accounting for the fact that `NaN !== NaN`.\n */\n\n\nfunction strictEquals(value1, value2) {\n  return value1 === value2 || value1 !== value1 && value2 !== value2;\n}\n/** Gets a map of default set of attributes to observe and the properties they affect. */\n\n\nfunction getDefaultAttributeToPropertyInputs(inputs) {\n  const attributeToPropertyInputs = {};\n  inputs.forEach(({\n    propName,\n    templateName\n  }) => {\n    attributeToPropertyInputs[camelToDashCase(templateName)] = propName;\n  });\n  return attributeToPropertyInputs;\n}\n/**\n * Gets a component's set of inputs. Uses the injector to get the component factory where the inputs\n * are defined.\n */\n\n\nfunction getComponentInputs(component, injector) {\n  const componentFactoryResolver = injector.get(ComponentFactoryResolver);\n  const componentFactory = componentFactoryResolver.resolveComponentFactory(component);\n  return componentFactory.inputs;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction extractProjectableNodes(host, ngContentSelectors) {\n  const nodes = host.childNodes;\n  const projectableNodes = ngContentSelectors.map(() => []);\n  let wildcardIndex = -1;\n  ngContentSelectors.some((selector, i) => {\n    if (selector === '*') {\n      wildcardIndex = i;\n      return true;\n    }\n\n    return false;\n  });\n\n  for (let i = 0, ii = nodes.length; i < ii; ++i) {\n    const node = nodes[i];\n    const ngContentIndex = findMatchingIndex(node, ngContentSelectors, wildcardIndex);\n\n    if (ngContentIndex !== -1) {\n      projectableNodes[ngContentIndex].push(node);\n    }\n  }\n\n  return projectableNodes;\n}\n\nfunction findMatchingIndex(node, selectors, defaultIndex) {\n  let matchingIndex = defaultIndex;\n\n  if (isElement(node)) {\n    selectors.some((selector, i) => {\n      if (selector !== '*' && matchesSelector(node, selector)) {\n        matchingIndex = i;\n        return true;\n      }\n\n      return false;\n    });\n  }\n\n  return matchingIndex;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Time in milliseconds to wait before destroying the component ref when disconnected. */\n\n\nconst DESTROY_DELAY = 10;\n/**\n * Factory that creates new ComponentNgElementStrategy instance. Gets the component factory with the\n * constructor's injector's factory resolver and passes that factory to each strategy.\n *\n * @publicApi\n */\n\nclass ComponentNgElementStrategyFactory {\n  constructor(component, injector) {\n    this.componentFactory = injector.get(ComponentFactoryResolver).resolveComponentFactory(component);\n  }\n\n  create(injector) {\n    return new ComponentNgElementStrategy(this.componentFactory, injector);\n  }\n\n}\n/**\n * Creates and destroys a component ref using a component factory and handles change detection\n * in response to input changes.\n *\n * @publicApi\n */\n\n\nclass ComponentNgElementStrategy {\n  constructor(componentFactory, injector) {\n    this.componentFactory = componentFactory;\n    this.injector = injector; // Subject of `NgElementStrategyEvent` observables corresponding to the component's outputs.\n\n    this.eventEmitters = new ReplaySubject(1);\n    /** Merged stream of the component's output events. */\n\n    this.events = this.eventEmitters.pipe(switchMap(emitters => merge(...emitters)));\n    /** Reference to the component that was created on connect. */\n\n    this.componentRef = null;\n    /** Reference to the component view's `ChangeDetectorRef`. */\n\n    this.viewChangeDetectorRef = null;\n    /**\n     * Changes that have been made to component inputs since the last change detection run.\n     * (NOTE: These are only recorded if the component implements the `OnChanges` interface.)\n     */\n\n    this.inputChanges = null;\n    /** Whether changes have been made to component inputs since the last change detection run. */\n\n    this.hasInputChanges = false;\n    /** Whether the created component implements the `OnChanges` interface. */\n\n    this.implementsOnChanges = false;\n    /** Whether a change detection has been scheduled to run on the component. */\n\n    this.scheduledChangeDetectionFn = null;\n    /** Callback function that when called will cancel a scheduled destruction on the component. */\n\n    this.scheduledDestroyFn = null;\n    /** Initial input values that were set before the component was created. */\n\n    this.initialInputValues = new Map();\n    /**\n     * Set of component inputs that have not yet changed, i.e. for which `recordInputChange()` has not\n     * fired.\n     * (This helps detect the first change of an input, even if it is explicitly set to `undefined`.)\n     */\n\n    this.unchangedInputs = new Set(this.componentFactory.inputs.map(({\n      propName\n    }) => propName));\n    /** Service for setting zone context. */\n\n    this.ngZone = this.injector.get(NgZone);\n    /** The zone the element was created in or `null` if Zone.js is not loaded. */\n\n    this.elementZone = typeof Zone === 'undefined' ? null : this.ngZone.run(() => Zone.current);\n  }\n  /**\n   * Initializes a new component if one has not yet been created and cancels any scheduled\n   * destruction.\n   */\n\n\n  connect(element) {\n    this.runInZone(() => {\n      // If the element is marked to be destroyed, cancel the task since the component was\n      // reconnected\n      if (this.scheduledDestroyFn !== null) {\n        this.scheduledDestroyFn();\n        this.scheduledDestroyFn = null;\n        return;\n      }\n\n      if (this.componentRef === null) {\n        this.initializeComponent(element);\n      }\n    });\n  }\n  /**\n   * Schedules the component to be destroyed after some small delay in case the element is just\n   * being moved across the DOM.\n   */\n\n\n  disconnect() {\n    this.runInZone(() => {\n      // Return if there is no componentRef or the component is already scheduled for destruction\n      if (this.componentRef === null || this.scheduledDestroyFn !== null) {\n        return;\n      } // Schedule the component to be destroyed after a small timeout in case it is being\n      // moved elsewhere in the DOM\n\n\n      this.scheduledDestroyFn = scheduler.schedule(() => {\n        if (this.componentRef !== null) {\n          this.componentRef.destroy();\n          this.componentRef = null;\n          this.viewChangeDetectorRef = null;\n        }\n      }, DESTROY_DELAY);\n    });\n  }\n  /**\n   * Returns the component property value. If the component has not yet been created, the value is\n   * retrieved from the cached initialization values.\n   */\n\n\n  getInputValue(property) {\n    return this.runInZone(() => {\n      if (this.componentRef === null) {\n        return this.initialInputValues.get(property);\n      }\n\n      return this.componentRef.instance[property];\n    });\n  }\n  /**\n   * Sets the input value for the property. If the component has not yet been created, the value is\n   * cached and set when the component is created.\n   */\n\n\n  setInputValue(property, value) {\n    this.runInZone(() => {\n      if (this.componentRef === null) {\n        this.initialInputValues.set(property, value);\n        return;\n      } // Ignore the value if it is strictly equal to the current value, except if it is `undefined`\n      // and this is the first change to the value (because an explicit `undefined` _is_ strictly\n      // equal to not having a value set at all, but we still need to record this as a change).\n\n\n      if (strictEquals(value, this.getInputValue(property)) && !(value === undefined && this.unchangedInputs.has(property))) {\n        return;\n      } // Record the changed value and update internal state to reflect the fact that this input has\n      // changed.\n\n\n      this.recordInputChange(property, value);\n      this.unchangedInputs.delete(property);\n      this.hasInputChanges = true; // Update the component instance and schedule change detection.\n\n      this.componentRef.instance[property] = value;\n      this.scheduleDetectChanges();\n    });\n  }\n  /**\n   * Creates a new component through the component factory with the provided element host and\n   * sets up its initial inputs, listens for outputs changes, and runs an initial change detection.\n   */\n\n\n  initializeComponent(element) {\n    const childInjector = Injector.create({\n      providers: [],\n      parent: this.injector\n    });\n    const projectableNodes = extractProjectableNodes(element, this.componentFactory.ngContentSelectors);\n    this.componentRef = this.componentFactory.create(childInjector, projectableNodes, element);\n    this.viewChangeDetectorRef = this.componentRef.injector.get(ChangeDetectorRef);\n    this.implementsOnChanges = isFunction(this.componentRef.instance.ngOnChanges);\n    this.initializeInputs();\n    this.initializeOutputs(this.componentRef);\n    this.detectChanges();\n    const applicationRef = this.injector.get(ApplicationRef);\n    applicationRef.attachView(this.componentRef.hostView);\n  }\n  /** Set any stored initial inputs on the component's properties. */\n\n\n  initializeInputs() {\n    this.componentFactory.inputs.forEach(({\n      propName\n    }) => {\n      if (this.initialInputValues.has(propName)) {\n        // Call `setInputValue()` now that the component has been instantiated to update its\n        // properties and fire `ngOnChanges()`.\n        this.setInputValue(propName, this.initialInputValues.get(propName));\n      }\n    });\n    this.initialInputValues.clear();\n  }\n  /** Sets up listeners for the component's outputs so that the events stream emits the events. */\n\n\n  initializeOutputs(componentRef) {\n    const eventEmitters = this.componentFactory.outputs.map(({\n      propName,\n      templateName\n    }) => {\n      const emitter = componentRef.instance[propName];\n      return emitter.pipe(map(value => ({\n        name: templateName,\n        value\n      })));\n    });\n    this.eventEmitters.next(eventEmitters);\n  }\n  /** Calls ngOnChanges with all the inputs that have changed since the last call. */\n\n\n  callNgOnChanges(componentRef) {\n    if (!this.implementsOnChanges || this.inputChanges === null) {\n      return;\n    } // Cache the changes and set inputChanges to null to capture any changes that might occur\n    // during ngOnChanges.\n\n\n    const inputChanges = this.inputChanges;\n    this.inputChanges = null;\n    componentRef.instance.ngOnChanges(inputChanges);\n  }\n  /**\n   * Marks the component view for check, if necessary.\n   * (NOTE: This is required when the `ChangeDetectionStrategy` is set to `OnPush`.)\n   */\n\n\n  markViewForCheck(viewChangeDetectorRef) {\n    if (this.hasInputChanges) {\n      this.hasInputChanges = false;\n      viewChangeDetectorRef.markForCheck();\n    }\n  }\n  /**\n   * Schedules change detection to run on the component.\n   * Ignores subsequent calls if already scheduled.\n   */\n\n\n  scheduleDetectChanges() {\n    if (this.scheduledChangeDetectionFn) {\n      return;\n    }\n\n    this.scheduledChangeDetectionFn = scheduler.scheduleBeforeRender(() => {\n      this.scheduledChangeDetectionFn = null;\n      this.detectChanges();\n    });\n  }\n  /**\n   * Records input changes so that the component receives SimpleChanges in its onChanges function.\n   */\n\n\n  recordInputChange(property, currentValue) {\n    // Do not record the change if the component does not implement `OnChanges`.\n    if (!this.implementsOnChanges) {\n      return;\n    }\n\n    if (this.inputChanges === null) {\n      this.inputChanges = {};\n    } // If there already is a change, modify the current value to match but leave the values for\n    // `previousValue` and `isFirstChange`.\n\n\n    const pendingChange = this.inputChanges[property];\n\n    if (pendingChange) {\n      pendingChange.currentValue = currentValue;\n      return;\n    }\n\n    const isFirstChange = this.unchangedInputs.has(property);\n    const previousValue = isFirstChange ? undefined : this.getInputValue(property);\n    this.inputChanges[property] = new SimpleChange(previousValue, currentValue, isFirstChange);\n  }\n  /** Runs change detection on the component. */\n\n\n  detectChanges() {\n    if (this.componentRef === null) {\n      return;\n    }\n\n    this.callNgOnChanges(this.componentRef);\n    this.markViewForCheck(this.viewChangeDetectorRef);\n    this.componentRef.changeDetectorRef.detectChanges();\n  }\n  /** Runs in the angular zone, if present. */\n\n\n  runInZone(fn) {\n    return this.elementZone && Zone.current !== this.elementZone ? this.ngZone.run(fn) : fn();\n  }\n\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Implements the functionality needed for a custom element.\n *\n * @publicApi\n */\n\n\nclass NgElement extends HTMLElement {\n  constructor() {\n    super(...arguments);\n    /**\n     * A subscription to change, connect, and disconnect events in the custom element.\n     */\n\n    this.ngElementEventsSubscription = null;\n  }\n\n}\n/**\n *  @description Creates a custom element class based on an Angular component.\n *\n * Builds a class that encapsulates the functionality of the provided component and\n * uses the configuration information to provide more context to the class.\n * Takes the component factory's inputs and outputs to convert them to the proper\n * custom element API and add hooks to input changes.\n *\n * The configuration's injector is the initial injector set on the class,\n * and used by default for each created instance.This behavior can be overridden with the\n * static property to affect all newly created instances, or as a constructor argument for\n * one-off creations.\n *\n * @see [Angular Elements Overview](guide/elements \"Turning Angular components into custom elements\")\n *\n * @param component The component to transform.\n * @param config A configuration that provides initialization information to the created class.\n * @returns The custom-element construction class, which can be registered with\n * a browser's `CustomElementRegistry`.\n *\n * @publicApi\n */\n\n\nfunction createCustomElement(component, config) {\n  const inputs = getComponentInputs(component, config.injector);\n  const strategyFactory = config.strategyFactory || new ComponentNgElementStrategyFactory(component, config.injector);\n  const attributeToPropertyInputs = getDefaultAttributeToPropertyInputs(inputs);\n\n  class NgElementImpl extends NgElement {\n    constructor(injector) {\n      super();\n      this.injector = injector;\n    }\n\n    get ngElementStrategy() {\n      // NOTE:\n      // Some polyfills (e.g. `document-register-element`) do not call the constructor, therefore\n      // it is not safe to set `ngElementStrategy` in the constructor and assume it will be\n      // available inside the methods.\n      //\n      // TODO(andrewseguin): Add e2e tests that cover cases where the constructor isn't called. For\n      // now this is tested using a Google internal test suite.\n      if (!this._ngElementStrategy) {\n        const strategy = this._ngElementStrategy = strategyFactory.create(this.injector || config.injector); // Re-apply pre-existing input values (set as properties on the element) through the\n        // strategy.\n\n        inputs.forEach(({\n          propName\n        }) => {\n          if (!this.hasOwnProperty(propName)) {\n            // No pre-existing value for `propName`.\n            return;\n          } // Delete the property from the instance and re-apply it through the strategy.\n\n\n          const value = this[propName];\n          delete this[propName];\n          strategy.setInputValue(propName, value);\n        });\n      }\n\n      return this._ngElementStrategy;\n    }\n\n    attributeChangedCallback(attrName, oldValue, newValue, namespace) {\n      const propName = attributeToPropertyInputs[attrName];\n      this.ngElementStrategy.setInputValue(propName, newValue);\n    }\n\n    connectedCallback() {\n      // For historical reasons, some strategies may not have initialized the `events` property\n      // until after `connect()` is run. Subscribe to `events` if it is available before running\n      // `connect()` (in order to capture events emitted during initialization), otherwise subscribe\n      // afterwards.\n      //\n      // TODO: Consider deprecating/removing the post-connect subscription in a future major version\n      //       (e.g. v11).\n      let subscribedToEvents = false;\n\n      if (this.ngElementStrategy.events) {\n        // `events` are already available: Subscribe to it asap.\n        this.subscribeToEvents();\n        subscribedToEvents = true;\n      }\n\n      this.ngElementStrategy.connect(this);\n\n      if (!subscribedToEvents) {\n        // `events` were not initialized before running `connect()`: Subscribe to them now.\n        // The events emitted during the component initialization have been missed, but at least\n        // future events will be captured.\n        this.subscribeToEvents();\n      }\n    }\n\n    disconnectedCallback() {\n      // Not using `this.ngElementStrategy` to avoid unnecessarily creating the `NgElementStrategy`.\n      if (this._ngElementStrategy) {\n        this._ngElementStrategy.disconnect();\n      }\n\n      if (this.ngElementEventsSubscription) {\n        this.ngElementEventsSubscription.unsubscribe();\n        this.ngElementEventsSubscription = null;\n      }\n    }\n\n    subscribeToEvents() {\n      // Listen for events from the strategy and dispatch them as custom events.\n      this.ngElementEventsSubscription = this.ngElementStrategy.events.subscribe(e => {\n        const customEvent = new CustomEvent(e.name, {\n          detail: e.value\n        });\n        this.dispatchEvent(customEvent);\n      });\n    }\n\n  } // Work around a bug in closure typed optimizations(b/79557487) where it is not honoring static\n  // field externs. So using quoted access to explicitly prevent renaming.\n\n\n  NgElementImpl['observedAttributes'] = Object.keys(attributeToPropertyInputs); // Add getters and setters to the prototype for each property input.\n\n  inputs.forEach(({\n    propName\n  }) => {\n    Object.defineProperty(NgElementImpl.prototype, propName, {\n      get() {\n        return this.ngElementStrategy.getInputValue(propName);\n      },\n\n      set(newValue) {\n        this.ngElementStrategy.setInputValue(propName, newValue);\n      },\n\n      configurable: true,\n      enumerable: true\n    });\n  });\n  return NgElementImpl;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @publicApi\n */\n\n\nconst VERSION = new Version('14.0.0');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NgElement, VERSION, createCustomElement };","map":{"version":3,"names":["ComponentFactoryResolver","NgZone","Injector","ChangeDetectorRef","ApplicationRef","SimpleChange","Version","ReplaySubject","merge","switchMap","map","scheduler","schedule","taskFn","delay","id","setTimeout","clearTimeout","scheduleBeforeRender","window","requestAnimationFrame","frameMs","cancelAnimationFrame","camelToDashCase","input","replace","char","toLowerCase","isElement","node","nodeType","Node","ELEMENT_NODE","isFunction","value","kebabToCamelCase","_","toUpperCase","_matches","matchesSelector","el","selector","elProto","Element","prototype","matches","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","call","strictEquals","value1","value2","getDefaultAttributeToPropertyInputs","inputs","attributeToPropertyInputs","forEach","propName","templateName","getComponentInputs","component","injector","componentFactoryResolver","get","componentFactory","resolveComponentFactory","extractProjectableNodes","host","ngContentSelectors","nodes","childNodes","projectableNodes","wildcardIndex","some","i","ii","length","ngContentIndex","findMatchingIndex","push","selectors","defaultIndex","matchingIndex","DESTROY_DELAY","ComponentNgElementStrategyFactory","constructor","create","ComponentNgElementStrategy","eventEmitters","events","pipe","emitters","componentRef","viewChangeDetectorRef","inputChanges","hasInputChanges","implementsOnChanges","scheduledChangeDetectionFn","scheduledDestroyFn","initialInputValues","Map","unchangedInputs","Set","ngZone","elementZone","Zone","run","current","connect","element","runInZone","initializeComponent","disconnect","destroy","getInputValue","property","instance","setInputValue","set","undefined","has","recordInputChange","delete","scheduleDetectChanges","childInjector","providers","parent","ngOnChanges","initializeInputs","initializeOutputs","detectChanges","applicationRef","attachView","hostView","clear","outputs","emitter","name","next","callNgOnChanges","markViewForCheck","markForCheck","currentValue","pendingChange","isFirstChange","previousValue","changeDetectorRef","fn","NgElement","HTMLElement","arguments","ngElementEventsSubscription","createCustomElement","config","strategyFactory","NgElementImpl","ngElementStrategy","_ngElementStrategy","strategy","hasOwnProperty","attributeChangedCallback","attrName","oldValue","newValue","namespace","connectedCallback","subscribedToEvents","subscribeToEvents","disconnectedCallback","unsubscribe","subscribe","e","customEvent","CustomEvent","detail","dispatchEvent","Object","keys","defineProperty","configurable","enumerable","VERSION"],"sources":["C:/Users/Lucetta/Desktop/Progetti Angular/WisiAI/node_modules/@angular/elements/fesm2020/elements.mjs"],"sourcesContent":["/**\n * @license Angular v14.0.0\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { ComponentFactoryResolver, NgZone, Injector, ChangeDetectorRef, ApplicationRef, SimpleChange, Version } from '@angular/core';\nimport { ReplaySubject, merge } from 'rxjs';\nimport { switchMap, map } from 'rxjs/operators';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Provide methods for scheduling the execution of a callback.\n */\nconst scheduler = {\n    /**\n     * Schedule a callback to be called after some delay.\n     *\n     * Returns a function that when executed will cancel the scheduled function.\n     */\n    schedule(taskFn, delay) {\n        const id = setTimeout(taskFn, delay);\n        return () => clearTimeout(id);\n    },\n    /**\n     * Schedule a callback to be called before the next render.\n     * (If `window.requestAnimationFrame()` is not available, use `scheduler.schedule()` instead.)\n     *\n     * Returns a function that when executed will cancel the scheduled function.\n     */\n    scheduleBeforeRender(taskFn) {\n        // TODO(gkalpak): Implement a better way of accessing `requestAnimationFrame()`\n        //                (e.g. accounting for vendor prefix, SSR-compatibility, etc).\n        if (typeof window === 'undefined') {\n            // For SSR just schedule immediately.\n            return scheduler.schedule(taskFn, 0);\n        }\n        if (typeof window.requestAnimationFrame === 'undefined') {\n            const frameMs = 16;\n            return scheduler.schedule(taskFn, frameMs);\n        }\n        const id = window.requestAnimationFrame(taskFn);\n        return () => window.cancelAnimationFrame(id);\n    },\n};\n/**\n * Convert a camelCased string to kebab-cased.\n */\nfunction camelToDashCase(input) {\n    return input.replace(/[A-Z]/g, char => `-${char.toLowerCase()}`);\n}\n/**\n * Check whether the input is an `Element`.\n */\nfunction isElement(node) {\n    return !!node && node.nodeType === Node.ELEMENT_NODE;\n}\n/**\n * Check whether the input is a function.\n */\nfunction isFunction(value) {\n    return typeof value === 'function';\n}\n/**\n * Convert a kebab-cased string to camelCased.\n */\nfunction kebabToCamelCase(input) {\n    return input.replace(/-([a-z\\d])/g, (_, char) => char.toUpperCase());\n}\nlet _matches;\n/**\n * Check whether an `Element` matches a CSS selector.\n * NOTE: this is duplicated from @angular/upgrade, and can\n * be consolidated in the future\n */\nfunction matchesSelector(el, selector) {\n    if (!_matches) {\n        const elProto = Element.prototype;\n        _matches = elProto.matches || elProto.matchesSelector || elProto.mozMatchesSelector ||\n            elProto.msMatchesSelector || elProto.oMatchesSelector || elProto.webkitMatchesSelector;\n    }\n    return el.nodeType === Node.ELEMENT_NODE ? _matches.call(el, selector) : false;\n}\n/**\n * Test two values for strict equality, accounting for the fact that `NaN !== NaN`.\n */\nfunction strictEquals(value1, value2) {\n    return value1 === value2 || (value1 !== value1 && value2 !== value2);\n}\n/** Gets a map of default set of attributes to observe and the properties they affect. */\nfunction getDefaultAttributeToPropertyInputs(inputs) {\n    const attributeToPropertyInputs = {};\n    inputs.forEach(({ propName, templateName }) => {\n        attributeToPropertyInputs[camelToDashCase(templateName)] = propName;\n    });\n    return attributeToPropertyInputs;\n}\n/**\n * Gets a component's set of inputs. Uses the injector to get the component factory where the inputs\n * are defined.\n */\nfunction getComponentInputs(component, injector) {\n    const componentFactoryResolver = injector.get(ComponentFactoryResolver);\n    const componentFactory = componentFactoryResolver.resolveComponentFactory(component);\n    return componentFactory.inputs;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction extractProjectableNodes(host, ngContentSelectors) {\n    const nodes = host.childNodes;\n    const projectableNodes = ngContentSelectors.map(() => []);\n    let wildcardIndex = -1;\n    ngContentSelectors.some((selector, i) => {\n        if (selector === '*') {\n            wildcardIndex = i;\n            return true;\n        }\n        return false;\n    });\n    for (let i = 0, ii = nodes.length; i < ii; ++i) {\n        const node = nodes[i];\n        const ngContentIndex = findMatchingIndex(node, ngContentSelectors, wildcardIndex);\n        if (ngContentIndex !== -1) {\n            projectableNodes[ngContentIndex].push(node);\n        }\n    }\n    return projectableNodes;\n}\nfunction findMatchingIndex(node, selectors, defaultIndex) {\n    let matchingIndex = defaultIndex;\n    if (isElement(node)) {\n        selectors.some((selector, i) => {\n            if ((selector !== '*') && matchesSelector(node, selector)) {\n                matchingIndex = i;\n                return true;\n            }\n            return false;\n        });\n    }\n    return matchingIndex;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Time in milliseconds to wait before destroying the component ref when disconnected. */\nconst DESTROY_DELAY = 10;\n/**\n * Factory that creates new ComponentNgElementStrategy instance. Gets the component factory with the\n * constructor's injector's factory resolver and passes that factory to each strategy.\n *\n * @publicApi\n */\nclass ComponentNgElementStrategyFactory {\n    constructor(component, injector) {\n        this.componentFactory =\n            injector.get(ComponentFactoryResolver).resolveComponentFactory(component);\n    }\n    create(injector) {\n        return new ComponentNgElementStrategy(this.componentFactory, injector);\n    }\n}\n/**\n * Creates and destroys a component ref using a component factory and handles change detection\n * in response to input changes.\n *\n * @publicApi\n */\nclass ComponentNgElementStrategy {\n    constructor(componentFactory, injector) {\n        this.componentFactory = componentFactory;\n        this.injector = injector;\n        // Subject of `NgElementStrategyEvent` observables corresponding to the component's outputs.\n        this.eventEmitters = new ReplaySubject(1);\n        /** Merged stream of the component's output events. */\n        this.events = this.eventEmitters.pipe(switchMap(emitters => merge(...emitters)));\n        /** Reference to the component that was created on connect. */\n        this.componentRef = null;\n        /** Reference to the component view's `ChangeDetectorRef`. */\n        this.viewChangeDetectorRef = null;\n        /**\n         * Changes that have been made to component inputs since the last change detection run.\n         * (NOTE: These are only recorded if the component implements the `OnChanges` interface.)\n         */\n        this.inputChanges = null;\n        /** Whether changes have been made to component inputs since the last change detection run. */\n        this.hasInputChanges = false;\n        /** Whether the created component implements the `OnChanges` interface. */\n        this.implementsOnChanges = false;\n        /** Whether a change detection has been scheduled to run on the component. */\n        this.scheduledChangeDetectionFn = null;\n        /** Callback function that when called will cancel a scheduled destruction on the component. */\n        this.scheduledDestroyFn = null;\n        /** Initial input values that were set before the component was created. */\n        this.initialInputValues = new Map();\n        /**\n         * Set of component inputs that have not yet changed, i.e. for which `recordInputChange()` has not\n         * fired.\n         * (This helps detect the first change of an input, even if it is explicitly set to `undefined`.)\n         */\n        this.unchangedInputs = new Set(this.componentFactory.inputs.map(({ propName }) => propName));\n        /** Service for setting zone context. */\n        this.ngZone = this.injector.get(NgZone);\n        /** The zone the element was created in or `null` if Zone.js is not loaded. */\n        this.elementZone = (typeof Zone === 'undefined') ? null : this.ngZone.run(() => Zone.current);\n    }\n    /**\n     * Initializes a new component if one has not yet been created and cancels any scheduled\n     * destruction.\n     */\n    connect(element) {\n        this.runInZone(() => {\n            // If the element is marked to be destroyed, cancel the task since the component was\n            // reconnected\n            if (this.scheduledDestroyFn !== null) {\n                this.scheduledDestroyFn();\n                this.scheduledDestroyFn = null;\n                return;\n            }\n            if (this.componentRef === null) {\n                this.initializeComponent(element);\n            }\n        });\n    }\n    /**\n     * Schedules the component to be destroyed after some small delay in case the element is just\n     * being moved across the DOM.\n     */\n    disconnect() {\n        this.runInZone(() => {\n            // Return if there is no componentRef or the component is already scheduled for destruction\n            if (this.componentRef === null || this.scheduledDestroyFn !== null) {\n                return;\n            }\n            // Schedule the component to be destroyed after a small timeout in case it is being\n            // moved elsewhere in the DOM\n            this.scheduledDestroyFn = scheduler.schedule(() => {\n                if (this.componentRef !== null) {\n                    this.componentRef.destroy();\n                    this.componentRef = null;\n                    this.viewChangeDetectorRef = null;\n                }\n            }, DESTROY_DELAY);\n        });\n    }\n    /**\n     * Returns the component property value. If the component has not yet been created, the value is\n     * retrieved from the cached initialization values.\n     */\n    getInputValue(property) {\n        return this.runInZone(() => {\n            if (this.componentRef === null) {\n                return this.initialInputValues.get(property);\n            }\n            return this.componentRef.instance[property];\n        });\n    }\n    /**\n     * Sets the input value for the property. If the component has not yet been created, the value is\n     * cached and set when the component is created.\n     */\n    setInputValue(property, value) {\n        this.runInZone(() => {\n            if (this.componentRef === null) {\n                this.initialInputValues.set(property, value);\n                return;\n            }\n            // Ignore the value if it is strictly equal to the current value, except if it is `undefined`\n            // and this is the first change to the value (because an explicit `undefined` _is_ strictly\n            // equal to not having a value set at all, but we still need to record this as a change).\n            if (strictEquals(value, this.getInputValue(property)) &&\n                !((value === undefined) && this.unchangedInputs.has(property))) {\n                return;\n            }\n            // Record the changed value and update internal state to reflect the fact that this input has\n            // changed.\n            this.recordInputChange(property, value);\n            this.unchangedInputs.delete(property);\n            this.hasInputChanges = true;\n            // Update the component instance and schedule change detection.\n            this.componentRef.instance[property] = value;\n            this.scheduleDetectChanges();\n        });\n    }\n    /**\n     * Creates a new component through the component factory with the provided element host and\n     * sets up its initial inputs, listens for outputs changes, and runs an initial change detection.\n     */\n    initializeComponent(element) {\n        const childInjector = Injector.create({ providers: [], parent: this.injector });\n        const projectableNodes = extractProjectableNodes(element, this.componentFactory.ngContentSelectors);\n        this.componentRef = this.componentFactory.create(childInjector, projectableNodes, element);\n        this.viewChangeDetectorRef = this.componentRef.injector.get(ChangeDetectorRef);\n        this.implementsOnChanges = isFunction(this.componentRef.instance.ngOnChanges);\n        this.initializeInputs();\n        this.initializeOutputs(this.componentRef);\n        this.detectChanges();\n        const applicationRef = this.injector.get(ApplicationRef);\n        applicationRef.attachView(this.componentRef.hostView);\n    }\n    /** Set any stored initial inputs on the component's properties. */\n    initializeInputs() {\n        this.componentFactory.inputs.forEach(({ propName }) => {\n            if (this.initialInputValues.has(propName)) {\n                // Call `setInputValue()` now that the component has been instantiated to update its\n                // properties and fire `ngOnChanges()`.\n                this.setInputValue(propName, this.initialInputValues.get(propName));\n            }\n        });\n        this.initialInputValues.clear();\n    }\n    /** Sets up listeners for the component's outputs so that the events stream emits the events. */\n    initializeOutputs(componentRef) {\n        const eventEmitters = this.componentFactory.outputs.map(({ propName, templateName }) => {\n            const emitter = componentRef.instance[propName];\n            return emitter.pipe(map(value => ({ name: templateName, value })));\n        });\n        this.eventEmitters.next(eventEmitters);\n    }\n    /** Calls ngOnChanges with all the inputs that have changed since the last call. */\n    callNgOnChanges(componentRef) {\n        if (!this.implementsOnChanges || this.inputChanges === null) {\n            return;\n        }\n        // Cache the changes and set inputChanges to null to capture any changes that might occur\n        // during ngOnChanges.\n        const inputChanges = this.inputChanges;\n        this.inputChanges = null;\n        componentRef.instance.ngOnChanges(inputChanges);\n    }\n    /**\n     * Marks the component view for check, if necessary.\n     * (NOTE: This is required when the `ChangeDetectionStrategy` is set to `OnPush`.)\n     */\n    markViewForCheck(viewChangeDetectorRef) {\n        if (this.hasInputChanges) {\n            this.hasInputChanges = false;\n            viewChangeDetectorRef.markForCheck();\n        }\n    }\n    /**\n     * Schedules change detection to run on the component.\n     * Ignores subsequent calls if already scheduled.\n     */\n    scheduleDetectChanges() {\n        if (this.scheduledChangeDetectionFn) {\n            return;\n        }\n        this.scheduledChangeDetectionFn = scheduler.scheduleBeforeRender(() => {\n            this.scheduledChangeDetectionFn = null;\n            this.detectChanges();\n        });\n    }\n    /**\n     * Records input changes so that the component receives SimpleChanges in its onChanges function.\n     */\n    recordInputChange(property, currentValue) {\n        // Do not record the change if the component does not implement `OnChanges`.\n        if (!this.implementsOnChanges) {\n            return;\n        }\n        if (this.inputChanges === null) {\n            this.inputChanges = {};\n        }\n        // If there already is a change, modify the current value to match but leave the values for\n        // `previousValue` and `isFirstChange`.\n        const pendingChange = this.inputChanges[property];\n        if (pendingChange) {\n            pendingChange.currentValue = currentValue;\n            return;\n        }\n        const isFirstChange = this.unchangedInputs.has(property);\n        const previousValue = isFirstChange ? undefined : this.getInputValue(property);\n        this.inputChanges[property] = new SimpleChange(previousValue, currentValue, isFirstChange);\n    }\n    /** Runs change detection on the component. */\n    detectChanges() {\n        if (this.componentRef === null) {\n            return;\n        }\n        this.callNgOnChanges(this.componentRef);\n        this.markViewForCheck(this.viewChangeDetectorRef);\n        this.componentRef.changeDetectorRef.detectChanges();\n    }\n    /** Runs in the angular zone, if present. */\n    runInZone(fn) {\n        return (this.elementZone && Zone.current !== this.elementZone) ? this.ngZone.run(fn) : fn();\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Implements the functionality needed for a custom element.\n *\n * @publicApi\n */\nclass NgElement extends HTMLElement {\n    constructor() {\n        super(...arguments);\n        /**\n         * A subscription to change, connect, and disconnect events in the custom element.\n         */\n        this.ngElementEventsSubscription = null;\n    }\n}\n/**\n *  @description Creates a custom element class based on an Angular component.\n *\n * Builds a class that encapsulates the functionality of the provided component and\n * uses the configuration information to provide more context to the class.\n * Takes the component factory's inputs and outputs to convert them to the proper\n * custom element API and add hooks to input changes.\n *\n * The configuration's injector is the initial injector set on the class,\n * and used by default for each created instance.This behavior can be overridden with the\n * static property to affect all newly created instances, or as a constructor argument for\n * one-off creations.\n *\n * @see [Angular Elements Overview](guide/elements \"Turning Angular components into custom elements\")\n *\n * @param component The component to transform.\n * @param config A configuration that provides initialization information to the created class.\n * @returns The custom-element construction class, which can be registered with\n * a browser's `CustomElementRegistry`.\n *\n * @publicApi\n */\nfunction createCustomElement(component, config) {\n    const inputs = getComponentInputs(component, config.injector);\n    const strategyFactory = config.strategyFactory || new ComponentNgElementStrategyFactory(component, config.injector);\n    const attributeToPropertyInputs = getDefaultAttributeToPropertyInputs(inputs);\n    class NgElementImpl extends NgElement {\n        constructor(injector) {\n            super();\n            this.injector = injector;\n        }\n        get ngElementStrategy() {\n            // NOTE:\n            // Some polyfills (e.g. `document-register-element`) do not call the constructor, therefore\n            // it is not safe to set `ngElementStrategy` in the constructor and assume it will be\n            // available inside the methods.\n            //\n            // TODO(andrewseguin): Add e2e tests that cover cases where the constructor isn't called. For\n            // now this is tested using a Google internal test suite.\n            if (!this._ngElementStrategy) {\n                const strategy = this._ngElementStrategy =\n                    strategyFactory.create(this.injector || config.injector);\n                // Re-apply pre-existing input values (set as properties on the element) through the\n                // strategy.\n                inputs.forEach(({ propName }) => {\n                    if (!this.hasOwnProperty(propName)) {\n                        // No pre-existing value for `propName`.\n                        return;\n                    }\n                    // Delete the property from the instance and re-apply it through the strategy.\n                    const value = this[propName];\n                    delete this[propName];\n                    strategy.setInputValue(propName, value);\n                });\n            }\n            return this._ngElementStrategy;\n        }\n        attributeChangedCallback(attrName, oldValue, newValue, namespace) {\n            const propName = attributeToPropertyInputs[attrName];\n            this.ngElementStrategy.setInputValue(propName, newValue);\n        }\n        connectedCallback() {\n            // For historical reasons, some strategies may not have initialized the `events` property\n            // until after `connect()` is run. Subscribe to `events` if it is available before running\n            // `connect()` (in order to capture events emitted during initialization), otherwise subscribe\n            // afterwards.\n            //\n            // TODO: Consider deprecating/removing the post-connect subscription in a future major version\n            //       (e.g. v11).\n            let subscribedToEvents = false;\n            if (this.ngElementStrategy.events) {\n                // `events` are already available: Subscribe to it asap.\n                this.subscribeToEvents();\n                subscribedToEvents = true;\n            }\n            this.ngElementStrategy.connect(this);\n            if (!subscribedToEvents) {\n                // `events` were not initialized before running `connect()`: Subscribe to them now.\n                // The events emitted during the component initialization have been missed, but at least\n                // future events will be captured.\n                this.subscribeToEvents();\n            }\n        }\n        disconnectedCallback() {\n            // Not using `this.ngElementStrategy` to avoid unnecessarily creating the `NgElementStrategy`.\n            if (this._ngElementStrategy) {\n                this._ngElementStrategy.disconnect();\n            }\n            if (this.ngElementEventsSubscription) {\n                this.ngElementEventsSubscription.unsubscribe();\n                this.ngElementEventsSubscription = null;\n            }\n        }\n        subscribeToEvents() {\n            // Listen for events from the strategy and dispatch them as custom events.\n            this.ngElementEventsSubscription = this.ngElementStrategy.events.subscribe(e => {\n                const customEvent = new CustomEvent(e.name, { detail: e.value });\n                this.dispatchEvent(customEvent);\n            });\n        }\n    }\n    // Work around a bug in closure typed optimizations(b/79557487) where it is not honoring static\n    // field externs. So using quoted access to explicitly prevent renaming.\n    NgElementImpl['observedAttributes'] = Object.keys(attributeToPropertyInputs);\n    // Add getters and setters to the prototype for each property input.\n    inputs.forEach(({ propName }) => {\n        Object.defineProperty(NgElementImpl.prototype, propName, {\n            get() {\n                return this.ngElementStrategy.getInputValue(propName);\n            },\n            set(newValue) {\n                this.ngElementStrategy.setInputValue(propName, newValue);\n            },\n            configurable: true,\n            enumerable: true,\n        });\n    });\n    return NgElementImpl;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @publicApi\n */\nconst VERSION = new Version('14.0.0');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NgElement, VERSION, createCustomElement };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}